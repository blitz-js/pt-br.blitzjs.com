---
title: Por que usar Blitz ao invés de Next.js?
sidebar_label: Por que Blitz ao invés de Next.js?
---

### 1. Fullstack ao invés de Frontend {#1-fullstack-instead-of-frontend}

Next.js é principalmente um framework frontend. Ele é feito para a
construir frontends que se conectam a alguma API. Next.js não é
configurado por padrão para construir uma verdadeira aplicação fullstack.

Blitz adiciona todas as funcionalidades que faltam e tornam o Next um
verdadeiro framework fullstack. Essas funcionalidades incluem acesso
direto a banco de dados, middleware, e autenticação.

### 2. Camada de Dados {#2-data-layer}

A nova camada de dados do Blitz é uma tecnologia origina para eleminar a
API e ainda manter renderização do lado do cliente. Em um app Blitz, você
pode importar o código do servidor direto no frontend para que você não
tenha que construir uma API e fazer a requisição de dados pelo frontend.
Em tempo de compilação, o Blitz automaticamente insere uma chamada a API
que roda o código de servidor no servidor. Essencialmente, o Blitz abstrai
sua API em um passo de compilação.

Essa é uma virada de jogo para o desenvolvimento de apps React porque ela
elimina uma porção inteira da arquitetura tradicional de apps React. Isso
significa que é mais fácil de aprender, mais rápido de desenvolver, e mais
divertido de construir coisas!

Dito isso, você ainda pode continuar fazendo requisição de dados via REST
ou GraphQL como sempre tem feito. Blitz não restringe isso de forma
alguma.

### 3. Autenticação Embutida {#3-built-in-authentication}

Blitz tem gerenciamento de sessão embutido que funciona com qualquer
provedor de identidade, incluindo email/senha e serviços terceiros.
Autenticação é algo complicado e difícil de implementar corretamente. Ter
ela embutida no Blitz te economiza um monte de tempo e potenciais
vulnerabilidades de segurança.

Construir uma experiência de usuário incrível com autenticação no Next.js
é bastante complicado e tedioso, mas o Blitz te dá a melhor que há
experiência de desenvolvimento de graça.

### 4. Convenções {#4-conventions}

Next.js não possui qualquer convenção além do roteamento baseado no
sistema de arquivos. Isso faz com que cada desenvolvedor tenha que
reinventar a roda em cada projeto.

Blitz traz um número de convenções para coisas como como organizar seus
arquivos e como estruturar suas rotas. Isso significa que você não perde
tempo descobrindo isso para cada projeto. Isso também beneficia
imensamente a comunidade. Estrutura de projeto e padrões arquiteturais em
comum fazem com que você mude de app Blitz pra app Blitz e imediatamente
se sinta em casa.

### 5. Scaffolding de Código {#5-code-scaffolding}

Existem duas maneiras principais de se reduzir a quantidade de código que
você tem que escrever na mão:

1. Geração de código
2. Scaffolding de código

**Geração de código** significa que uma biblioteca gera código pra você.
Exemplos são o graphql-code-generator que gera código a partir de queries
GraphQL e Hasura que gera uma API GraphQL inteira a partir do schema do
seu banco de dados. Geralmente, geração de código não possui uma forma de
customizar completamente o código gerado. Você fica nas mãos da biblioteca
e do que ela suporta. Frequentemente você esbarra em casos de contorno que
a geração de código não tem solução. E você não pode consertar porque você
não é dono do código.

**Scaffolding de código** significa que o código é inicialmente "gerado"
no seu projeto pra você. A partir de então, você tem total propriedade
sobre todo o código e pode customizá-lo o quanto precisar. Uma desvantagem
do scaffolding de código é que você não recebe atualizações automáticas do
código como você recebe com geração de código de uma biblioteca de
terceiros. Mas a grande vantagem é que você tem a garantia de nunca ficar
limitado pelo design de outra pessoa e que você não tem como mudar.

Blitz é um grande fã de scaffolding de código. Nós temos uma enorme
quantidade de comandos [`blitz generate`](./cli-generate) para fazer o
scaffolding de código no seu projeto. Ainda estamos no início do nosso
scaffolding de código — nós temos várias funcionalidades poderosas que
ainda precisam ser adicionadas, incluindo a habilidade de adicionar seu
próprio template de scaffold personalizado.

### 6. Receitas {#6-recipes}

Receitas são comandos de uma linha para fazer scaffolding de código no seu
projeto a partir de um receita MDX no npm ou num repositório git.

Exemplos:

- `blitz install tailwind` - um comando para instalar e configurar o
  tailwind
- `blitz install chakra-ui` - um comando para instalar e configurar o
  chakra-ui
- `blitz install material-ui` - um comando para instalar e configurar o
  material-ui

Receitas são super poderosas. Elas podem alterar quase tudo no seu
projeto, incluindo adicionar dependencias, alterar código, adicionar
código, etc. Elas são escritas com MDX e podem ser compostas assim como
componentes React.

### 7. Desenvolvimento de Novos Apps {#7-new-app-development}

Um app Next.js novo é totalmente "bare-bones". Então toda vez que você
inicia um projeto Next.js, você tem que gastar horas configurando todo o
básico como eslint, prettier, hooks do git do husky, etc.

Um ap Blitz novo te salva bastante tempo porque tudo isso vem
pré-configurado para você! Com certeza você sempre pode customizar depois,
mas ter um ponto de partida que funciona é demais!

### 8. Restrições Relaxadas {#8-relaxed-restrictions}

Next.js requer que todas a suas páginas React fiquem em uma única pasta
`pages/`. Blitz relaxa essa restrição permitindo que você tenha um número
infinito de pastas `pages/`.

Para projetos grandes esse é um benefício enorme porque você pode separar
e organizar suas páginas de qualquer maneira que quiser.

Exemplos:

- `app/pages/` poderia conter a página inicial e páginas como "sobre"
- `app/products/pages/` poderia conter todas as páginas relacionadas a
  produtos
- `app/admin/pages/` poderia conter todas as páginas relacionas à seção de
  admin

### 9. Manifesto de rotas {#9-route-manifest}

Next.js requer que você escreva manualmente a localização de suas páginas.
Blitz vem com um [Manifesto de Rotas](./route-manifest), para que você
possa fazer:

```tsx
<Link href={Routes.ProductsPage({ productId: 123 })} />
// ao invés de
<Link href={`/products/${123}`} />
```

Isso melhora a expressividade e simplifica a mudança de páginas para
diferentes localizações.
