---
title: Tutorial
sidebar_label: Tutorial
---

Neste tutorial, vamos orient√°-lo na cria√ß√£o de um aplicativo b√°sico de
vota√ß√£o.

Vamos assumir que voc√™ j√° tenha o [Blitz instalado](./get-started). Voc√™
pode saber se o Blitz est√° instalado e qual vers√£o voc√™ possui executando
o seguinte comando em seu terminal:

```sh
blitz -v
```

Se o Blitz estiver instalado, voc√™ dever√° ver a vers√£o de sua instala√ß√£o.
Se n√£o estiver, voc√™ receber√° um erro dizendo algo como ‚Äúcommand not
found: blitz‚Äù.

## Criando um novo app {#creating-a-new-app}

Na linha de comando, v√° para a pasta onde deseja criar seu aplicativo e
execute o seguinte comando:

```sh
blitz new meu-app-blitz
```

Blitz criar√° uma pasta `meu-app-blitz` em sua pasta atual. Voc√™ ser√°
solicitado a escolher uma biblioteca de formul√°rios. Para este tutorial,
selecione a biblioteca recomendada `React Final Form`.

Vejamos o que `blitz new` criou:

```
meu-app-blitz
‚îú‚îÄ‚îÄ app/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mutations/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ changePassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logout.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgot-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validations.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Form.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ LabeledTextField.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ layouts/
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ Layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 404.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _app.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _document.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.test.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ users/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ queries/
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ getCurrentUser.ts
‚îú‚îÄ‚îÄ db/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ seeds.ts
‚îú‚îÄ‚îÄ integrations/
‚îú‚îÄ‚îÄ mailers/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ forgotPasswordMailer.ts
‚îú‚îÄ‚îÄ public/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico*
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ test/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.tsx
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ blitz.config.js
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ types.d.ts
‚îú‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ yarn.lock
```

Esses arquivos s√£o:

- A pasta `app/` √© um cont√™iner para a maior parte do seu projeto. √â aqui
  que voc√™ colocar√° todas as p√°ginas ou rotas de API.

- A pasta `app/pages/` √© a principal pasta das p√°ginas. Se voc√™ j√° usou
  Next.js, notar√° essa diferen√ßa imediatamente. No Blitz, voc√™ pode ter
  muitas pastas `pages` e elas ser√£o mescladas no momento da constru√ß√£o
  (build time).

- A pasta `app/core/` √© o principal local para colocar componentes, hooks,
  etc, que s√£o usados em todo o seu app.

- `db/` √© onde vai a configura√ß√£o do seu banco de dados. Se voc√™ estiver
  escrevendo modelos ou verificando migra√ß√µes (migrations), √© aqui que
  voc√™ deve verificar.

- `public/` √© a pasta onde voc√™ colocar√° quaisquer ativos est√°ticos. Se
  voc√™ tiver imagens, arquivos ou v√≠deos que deseja usar em seu app, aqui
  √© onde voc√™ deve coloc√°-los.

- `.babelrc.js`, `.env`, etc. ("dotfiles") s√£o arquivos de configura√ß√£o
  para v√°rias ferramentas JavaScript.

- `blitz.config.js` √© para configura√ß√£o personalizada avan√ßada do Blitz.
  Utiliza o mesmo formato que o `next.config.js`.

- `tsconfig.json` √© nossa configura√ß√£o recomendada para TypeScript.

## O servidor de desenvolvimento {#the-development-server}

Agora certifique-se de que est√° na pasta `meu-app-blitz` e execute o
seguinte comando:

```sh
blitz dev
```

Voc√™ ver√° a seguinte sa√≠da na linha de comando:

```sh
‚úî Compiled
Loaded env from /private/tmp/meu-app-blitz/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /meu-app-blitz/babel.config.js
event - compiled successfully
```

Agora que o servidor est√° em execu√ß√£o, visite
[localhost:3000](http://localhost:3000) com seu navegador. Voc√™ ver√° uma
p√°gina de boas-vindas, com o logotipo do Blitz. It worked!

## Cadastre-se como um usu√°rio {#sign-up-as-a-user}

Os apps Blitz s√£o criados com o cadastro e login de usu√°rio j√°
configurados! Ent√£o, vamos testar. Clique no bot√£o **Sign Up**
(Cadastrar-se). Digite qualquer e-mail e senha e clique em **Create
Account** (Criar Conta). Em seguida, voc√™ ser√° redirecionado de volta para
a p√°gina inicial, onde pode ver seu usu√°rio `id` e `role`.

Se quiser, voc√™ tamb√©m pode tentar sair e fazer login novamente. Ou clique
em **Forgot your password?** (Esqueceu sua senha?) na p√°gina de login para
testar esse fluxo.

## Escreva sua primeira p√°gina {#write-your-first-page}

Em seguida, vamos criar sua primeira p√°gina.

Abra o arquivo `app/pages/index.tsx` e substitua o conte√∫do do componente
`Home` por:

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Hello, world!</h1>

      <Suspense fallback="Carregando...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Salve o arquivo e voc√™ ver√° a atualiza√ß√£o da p√°gina em seu navegador. Voc√™
pode personalizar isso o quanto quiser. Quando estiver pronto, v√° para a
pr√≥xima se√ß√£o.

## Configura√ß√£o de banco de dados {#database-setup}

Boas not√≠cias, um banco de dados SQLite j√° foi configurado para voc√™! Voc√™
pode executar o `blitz prisma studio` no terminal para abrir uma interface
web onde voc√™ pode ver os dados de seu banco de dados.

Observe que ao iniciar seu primeiro projeto real, voc√™ pode querer usar um
banco de dados mais escal√°vel como o PostgreSQL, para evitar o inc√¥modo de
alterar seu banco de dados ao longo do caminho. Para obter mais
informa√ß√µes, consulte [Vis√£o geral do banco de dados](database-overview).
Por enquanto, continuaremos com o banco de dados padr√£o SQLite.

## Gerando a estrutura dos nossos modelos {#scaffolding-code-for-our-models}

O Blitz fornece um comando pr√°tico de CLI chamado
[`generate`](./cli-generate) para gerar a estrutura inicial do nosso
c√≥digo. Usaremos `generate` para criar dois modelos: `Question` (Quest√£o)
e `Choice` (Op√ß√£o). Uma `Question` cont√©m o texto da pergunta e uma lista
de op√ß√µes. Uma `Choice` tem o texto da op√ß√£o, uma contagem de votos e uma
quest√£o associada. O Blitz ir√° gerar automaticamente um id, um timestamp
(data e hora) de cria√ß√£o e um timestamp da √∫ltima atualiza√ß√£o para ambos
os modelos.

#### Primeiro, vamos gerar tudo o que pertence ao modelo `Question`:

```sh
blitz generate all question text:string
```

E quando solicitado, pressione **Enter** para executar `prisma migrate`
que ir√° atualizar seu esquema de banco de dados com o novo modelo. Ele
pedir√° um nome, ent√£o digite algo como "add question" (adicionar
pergunta).

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
‚úî Compiled
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

‚úî Model 'Question' created in schema.prisma:

>
> model Question {
>   id        Int      @id @default(autoincrement())
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }
>

‚úî Run 'prisma migrate dev' to update your database? (Y/n) ¬∑ true
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Enter a name for the new migration: ‚Ä¶ add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210722070215_add_question/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.

‚úî Generated Prisma Client (2.27.0) to ./node_modules/@prisma/client in 187ms
```

O comando `generate` do tipo `all` gera um model (modelo), queries,
mutations e arquivos de p√°gina. Veja a p√°gina
[Blitz generate](./cli-generate) para ver a lista de op√ß√µes dispon√≠veis.

#### A seguir, geraremos o modelo `Choice` com suas queries e mutations correspondentes.

Vamos passar o tipo `resource` (recurso) desta vez, pois n√£o precisamos
gerar p√°ginas para o modelo `Choice`:

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

Se voc√™ receber um erro, execute `blitz prisma format`.

Note que isso n√£o requer uma migra√ß√£o de banco de dados porque ainda n√£o
adicionamos o campo `Choice` ao modelo `Question`. Portanto, estamos
escolhendo `false` quando solicitado para executar a migra√ß√£o:

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

‚úî Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) ‚Ä∫ false
```

#### Por √∫ltimo, vamos atualizar o modelo `Question` para ter um relacionamento de volta com `Choice`.

Abra o `db/schema.prisma` e adicione `choices Choice[]` ao modelo
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

Agora podemos executar a migra√ß√£o para atualizar nosso banco de dados:

```sh
blitz prisma migrate dev
```

E novamente, insira um nome para a migra√ß√£o, como "add choice" (adicionar
op√ß√£o):

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Name of migration ‚Ä¶ add choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210412175528_add_choice/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.
```

Agora nosso banco de dados est√° pronto e um cliente Prisma tamb√©m foi
gerado. Vamos continuar para testarmos o cliente Prisma!

## Testando o cliente de banco de dados Prisma {#playing-with-the-prisma-database-client}

Agora, vamos para o shell interativo do Blitz e testar o cliente de banco
de dados Prisma que o Blitz oferece. Para iniciar o console Blitz, use
este comando:

```sh
blitz console
```

Quando estiver no console, explore o cliente de banco de dados:

```sh
# Ainda n√£o h√° perguntas no sistema.
‚ö° > await db.question.findMany()
[]

# Crie uma nova Pergunta:
‚ö° > let q = await db.question.create({data: {text: "Quais as novidades?"}})
undefined

# Veja o objeto inteiro:
‚ö° > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "Quais as novidades?"
}

# Ou acesse valores individuais no objeto:
‚ö° > q.text
"Quais as novidades?"

# Altere os valores usando a fun√ß√£o de update:
‚ö° > q = await db.question.update({where: {id: 1}, data: {text: "E a√≠?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "E a√≠?"
}

# db.question.findMany() agora exibe todas as perguntas do banco de dados:
‚ö° > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "E a√≠?"
  }
]
```

## Atualize o c√≥digo gerado para os atributos do nosso modelo {#update-generated-code-for-our-model-attributes}

<Card type="info">

Antes de executar o app novamente, precisamos personalizar parte do c√≥digo
que foi gerado. No final das contas, essas corre√ß√µes n√£o ser√£o
necess√°rias - mas, por enquanto, precisamos solucionar alguns problemas
pendentes.

</Card>

No momento, o conte√∫do gerado da p√°gina n√£o usa os atributos do modelo
real que voc√™ definiu durante a gera√ß√£o. Ir√° usar em breve, mas enquanto
isso, vamos corrigir as p√°ginas geradas.

### P√°ginas das Perguntas {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

V√° para `app/pages/questions/index.tsx`. Observe que um componente
`QuestionsList` foi gerado para voc√™:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{ questions, hasMore }, { isPreviousData }] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: { id: "asc" },
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    }
  )

  const goToPreviousPage = () =>
    router.push({ query: { page: page - 1 } })

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({ query: { page: page + 1 } })
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Anterior
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Pr√≥ximo
      </button>
    </div>
  )
}
```

Mas isso n√£o vai funcionar! Lembre-se de que o modelo `Question` que
criamos acima n√£o possui nenhum campo `name`. Para corrigir isso,
substitua `question.name` por `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Anterior
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Pr√≥ximo
      </button>
    </div>
  )
}
```

A seguir, vamos aplicar uma corre√ß√£o semelhante a
`app/questions/components/QuestionForm.tsx`. No envio do formul√°rio,
substitua o `LabeledTextField` `name` por `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Texto" placeholder="Texto" />
    </Form>
  )
}
```

### `createQuestion` mutation {#create-question-mutation}

Em `app/questions/mutations/createQuestion.ts`, precisamos atualizar o
esquema de valida√ß√£o do zod `CreateQuestion` para usar `text` em vez de
`name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `updateQuestion` mutation {#update-question-mutation}

Em `app/questions/mutations/updateQuestion.ts`, precisamos atualizar o
esquema de valida√ß√£o do zod `UpdateQuestion` para usar `text` em vez de
`name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:

O Prisma ainda n√£o suporta "cascading deletes". No contexto deste
tutorial, isso significa que atualmente ele n√£o exclui os dados de
`Choice` ao excluir uma `Question`. Precisamos alterar temporariamente a
mutation `deleteQuestion` gerada para fazer isso manualmente. Abra
`app/questions/mutations/deleteQuestion.ts` em seu editor de texto e
adicione o seguinte ao topo do corpo da fun√ß√£o:

```ts
await db.choice.deleteMany({ where: { questionId: id } })
```

O resultado final deve ser o seguinte:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

Esta mutation agora excluir√° as op√ß√µes associadas √† pergunta antes de
excluir a pr√≥pria pergunta.

#### Agora tente criar, atualizar e excluir perguntas

Excelente! Agora certifique-se de que seu app esteja em execu√ß√£o. Se n√£o
estiver, execute `blitz dev` em seu terminal e visite
`localhost:3000/questions`. Tente criar perguntas, editar e exclu√≠-las.

## Adicionando op√ß√µes ao formul√°rio da pergunta {#adding-choices-to-the-question-form}

Voc√™ est√° indo muito bem at√© agora! A pr√≥xima coisa que faremos √©
adicionar op√ß√µes ao nosso formul√°rio de perguntas. Abra
`app/questions/components/QuestionForm.tsx` em seu editor.

Adicione mais tr√™s componentes `<LabeledTextField>` como op√ß√µes.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Texto" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Op√ß√£o 1" />
+     <LabeledTextField name="choices.1.text" label="Op√ß√£o 2" />
+     <LabeledTextField name="choices.2.text" label="Op√ß√£o 3" />
    </Form>
  )
}
```

Em seguida, abra `app/pages/questions/new.tsx` e defina o `initialValues`
como a seguir:

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

Em seguida, abra `app/questions/mutations/createQuestion.ts` e atualize o
esquema do zod para que os dados das op√ß√µes sejam aceitos na mutation. E
tamb√©m precisamos atualizar a chamada `db.question.create` para que as
op√ß√µes tamb√©m sejam criadas.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### Experimente

Agora voc√™ pode ir para `localhost:3000/questions/new` e criar uma nova
quest√£o com op√ß√µes!

## Listing choices {#listing-choices}

Time for a breather. Go back to `localhost:3000/questions` in your browser
and look at all the questions you‚Äòve created. How about we list these
questions‚Äô choices here too? First, we need to customize the question
queries. In Prisma, you need to manually let the client know that you want
to query for nested relations. Change your `getQuestion.ts` and
`getQuestions.ts` files to look like this:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Now check `/questions` in the browser. **Magic!**

## Let‚Äôs let people vote on these questions! {#let-people-vote-on-questions}

Open `app/pages/questions/[questionId].tsx` in your editor. First, we‚Äôre
going to improve this page somewhat.

1. Replace `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Delete the `pre` element, and copy in our choices list which we wrote
   before:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

If you go back to your browser, your page should now look something like
this!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Now it‚Äôs time to add voting!

First we need to open `app/choices/mutations/updateChoice.ts`, update the
zod schema, and add a vote increment.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Now go back to `app/pages/questions/[questionId].tsx` and make the
following changes:

In our `li`, add a `button` like so:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

Then, import the `updateChoice` mutation we updated and create a
`handleVote` function in our page:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finally, we‚Äôll tell our new `button` to call that function!

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

The final `Question` component should now look like this:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, { refetch }] = useQuery(getQuestion, {
    id: questionId,
  })
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({ id })
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({ id: question.id })
              router.push("/questions")
            }
          }}
          style={{ marginLeft: "0.5rem" }}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Lastly, let's allow editing choices for an existing question {#edit-choices-for-question}

If you click the **Edit** button on one of your existing questions, you'll
see it uses the same form as creating questions. So that part is already
done! We only need to update our mutation.

Open `app/questions/mutations/updateQuestion.ts` and make the following
changes:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+     include: {
+       choices: true,
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
is a special operation that means, "If this item exists, update it. Else
create it". This is perfect for this case because we didn't require the
user to add three choices when creating the question. So if later the user
adds another choice by editing the question, then it'll be created here.

## Cleanup {#cleanup}

In order for `yarn tsc` or `git push` to succeed, you'll need to delete
`app/choices/mutations/createChoice.ts` (unused) or update the
CreateChoice zod schema to include the required fields.

## Conclusion {#conclusion}

ü•≥ Congrats! You created your very own Blitz app! Have fun playing around
with it, or sharing it with your friends. Now that you‚Äôve finished this
tutorial, why not try making your voting app even better? You could try:

- Adding styling (Hint, try `blitz install tailwind` or
  `blitz install chakra-ui`)
- Showing some more statistics about votes
- Deploying live on [Render](./deploy-render) or [Vercel](./deploy-vercel)

If you want to share your project with the world wide Blitz community
there is no better place to do that than on Discord.

Visit [discord.blitzjs.com](https://discord.blitzjs.com). Then, post the
link to the **#built-with-blitz** channel to share it with everyone!
