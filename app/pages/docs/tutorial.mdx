---
title: Tutorial
sidebar_label: Tutorial
---

Neste tutorial, vamos orientá-lo na criação de um aplicativo básico de
votação.

Vamos assumir que você já tenha o [Blitz instalado](./get-started). Você
pode saber se o Blitz está instalado e qual versão você possui executando
o seguinte comando em seu terminal:

```sh
blitz -v
```

Se o Blitz estiver instalado, você deverá ver a versão de sua instalação.
Se não estiver, você receberá um erro dizendo algo como “command not
found: blitz”.

## Criando um novo app {#creating-a-new-app}

Na linha de comando, vá para a pasta onde deseja criar seu aplicativo e
execute o seguinte comando:

```sh
blitz new meu-app-blitz
```

Blitz criará uma pasta `meu-app-blitz` em sua pasta atual. Você será
solicitado a escolher uma biblioteca de formulários. Para este tutorial,
selecione a biblioteca recomendada `React Final Form`.

Vejamos o que `blitz new` criou:

```
meu-app-blitz
├── app/
│   ├── api/
│   ├── auth/
│   │   ├── components/
│   │   │   ├── LoginForm.tsx
│   │   │   └── SignupForm.tsx
│   │   ├── mutations/
│   │   │   ├── changePassword.ts
│   │   │   ├── forgotPassword.test.ts
│   │   │   ├── forgotPassword.ts
│   │   │   ├── login.ts
│   │   │   ├── logout.ts
│   │   │   ├── resetPassword.test.ts
│   │   │   ├── resetPassword.ts
│   │   │   └── signup.ts
│   │   ├── pages/
│   │   │   ├── forgot-password.tsx
│   │   │   ├── login.tsx
│   │   │   ├── reset-password.tsx
│   │   │   └── signup.tsx
│   │   └── validations.ts
│   ├── core/
│   │   ├── components/
│   │   │   ├── Form.tsx
│   │   │   └── LabeledTextField.tsx
│   │   ├── hooks/
│   │   │   └── useCurrentUser.ts
│   │   └── layouts/
│   │       └── Layout.tsx
│   ├── pages/
│   │   ├── 404.tsx
│   │   ├── _app.tsx
│   │   ├── _document.tsx
│   │   ├── index.test.tsx
│   │   └── index.tsx
│   └── users/
│       └── queries/
│           └── getCurrentUser.ts
├── db/
│   ├── index.ts
│   ├── schema.prisma
│   └── seeds.ts
├── integrations/
├── mailers/
│   └── forgotPasswordMailer.ts
├── public/
│   ├── favicon.ico*
│   └── logo.png
├── test/
│   ├── setup.ts
│   └── utils.tsx
├── README.md
├── babel.config.js
├── blitz.config.js
├── jest.config.js
├── package.json
├── tsconfig.json
├── types.d.ts
├── types.ts
└── yarn.lock
```

Esses arquivos são:

- A pasta `app/` é um contêiner para a maior parte do seu projeto. É aqui
  que você colocará todas as páginas ou rotas de API.

- A pasta `app/pages/` é a principal pasta das páginas. Se você já usou
  Next.js, notará essa diferença imediatamente. No Blitz, você pode ter
  muitas pastas `pages` e elas serão mescladas no momento da construção
  (build time).

- A pasta `app/core/` é o principal local para colocar componentes, hooks,
  etc, que são usados em todo o seu app.

- `db/` é onde vai a configuração do seu banco de dados. Se você estiver
  escrevendo modelos ou verificando migrações (migrations), é aqui que
  você deve verificar.

- `public/` é a pasta onde você colocará quaisquer ativos estáticos. Se
  você tiver imagens, arquivos ou vídeos que deseja usar em seu app, é
  aqui que você deve colocá-los.

- `public/` is a folder where you will put any static assets. If you have
  images, files, or videos which you want to use in your app, this is
  where to put them.

- `.babelrc.js`, `.env`, etc. ("dotfiles") são arquivos de configuração
  para várias ferramentas JavaScript.

- `blitz.config.js` é para configuração personalizada avançada do Blitz.
  Utiliza o mesmo formato que o `next.config.js`.

- `tsconfig.json` é nossa configuração recomendada para TypeScript.

## O servidor de desenvolvimento {#the-development-server}

Agora certifique-se de que está na pasta `meu-app-blitz` e execute o
seguinte comando:

```sh
blitz dev
```

Você verá a seguinte saída na linha de comando:

```sh
✔ Compiled
Loaded env from /private/tmp/meu-app-blitz/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /meu-app-blitz/babel.config.js
event - compiled successfully
```

Agora que o servidor está em execução, visite
[localhost:3000](http://localhost:3000) com seu navegador. Você verá uma
página de boas-vindas, com o logotipo do Blitz. It worked!

## Cadastre-se como um usuário {#sign-up-as-a-user}

Os apps Blitz são criados com o cadastro e login de usuário já
configurados! Então, vamos testar. Clique no botão **Sign Up**
(Cadastrar-se). Digite qualquer e-mail e senha e clique em **Create
Account** (Criar Conta). Em seguida, você será redirecionado de volta para
a página inicial, onde pode ver seu usuário `id` e `role`.

Se quiser, você também pode tentar sair e fazer login novamente. Ou clique
em **Forgot your password?** (Esqueceu sua senha?) na página de login para
testar esse fluxo.

## Escreva sua primeira página {#write-your-first-page}

Em seguida, vamos criar sua primeira página.

Abra o arquivo `app/pages/index.tsx` e substitua o conteúdo do componente
`Home` por:

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Hello, world!</h1>

      <Suspense fallback="Loading...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Salve o arquivo e você verá a atualização da página em seu navegador. Você
pode personalizar isso o quanto quiser. Quando estiver pronto, vá para a
próxima seção.

## Configuração de banco de dados {#database-setup}

Boas notícias, um banco de dados SQLite já foi configurado para você! Você
pode executar o `blitz prisma studio` no terminal para abrir uma interface
web onde você pode ver os dados de seu banco de dados.

Observe que ao iniciar seu primeiro projeto real, você pode querer usar um
banco de dados mais escalável como o PostgreSQL, para evitar o incômodo de
alterar seu banco de dados ao longo do caminho. Para obter mais
informações, consulte [Visão geral do banco de dados](database-overview).
Por enquanto, continuaremos com o banco de dados padrão SQLite.

## Gerando a estrutura dos nossos modelos {#scaffolding-code-for-our-models}

O Blitz fornece um comando prático de CLI chamado
[`generate`](./cli-generate) para gerar a estrutura inicial do nosso
código. Usaremos `generate` para criar dois modelos: `Question` (Questão)
e `Choice` (Opção). Uma `Question` contém o texto da pergunta e uma lista
de opções. Uma `Choice` tem o texto da opção, uma contagem de votos e uma
questão associada. O Blitz irá gerar automaticamente um id, um timestamp
(data e hora) de criação e um timestamp da última atualização para ambos
os modelos.

#### Primeiro, vamos gerar tudo o que pertence ao modelo `Question`:

```sh
blitz generate all question text:string
```

E quando solicitado, pressione **Enter** para executar `prisma migrate`
que irá atualizar seu esquema de banco de dados com o novo modelo. Ele
pedirá um nome, então digite algo como "add question" (adicionar
pergunta).

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
✔ Compiled
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

✔ Model 'Question' created in schema.prisma:

>
> model Question {
>   id        Int      @id @default(autoincrement())
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }
>

✔ Run 'prisma migrate dev' to update your database? (Y/n) · true
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

✔ Enter a name for the new migration: … add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20210722070215_add_question/
    └─ migration.sql

Your database is now in sync with your schema.

✔ Generated Prisma Client (2.27.0) to ./node_modules/@prisma/client in 187ms
```

O comando `generate` do tipo `all` gera um model (modelo), queries
(consultas), mutations (mutações) e arquivos de página. Veja a página
[Blitz generate](./cli-generate) para ver a lista de opções disponíveis.

#### A seguir, geraremos o modelo `Choice` com suas queries e mutations correspondentes.

Vamos passar o tipo `resource` (recurso) desta vez, pois não precisamos
gerar páginas para o modelo `Choice`:

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

Se você receber um erro, execute `blitz prisma format`.

Note that this doesn't require a database migration because we haven't
added the `Choice` field to the `Question` model yet. So we are choosing
`false` when prompted to run the migration:

Note que isso não requer uma migração de banco de dados porque ainda não
adicionamos o campo `Choice` ao modelo `Question`. Portanto, estamos
escolhendo `false` quando solicitado para executar a migração:

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

✔ Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) › false
```

#### Lastly let's update the `Question` model to have a relationship back to `Choice`.

#### Por último, vamos atualizar o modelo `Question` para ter um relacionamento de volta com `Choice`.

Abra o `db/schema.prisma` e adicione `choices Choice[]` ao modelo
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

Agora podemos executar a migração para atualizar nosso banco de dados:

```sh
blitz prisma migrate dev
```

E novamente, insira um nome para a migração, como "add choice" (adicionar
opção):

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

✔ Name of migration … add choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20210412175528_add_choice/
    └─ migration.sql

Your database is now in sync with your schema.
```

Agora nosso banco de dados está pronto e um cliente Prisma também foi
gerado. Vamos continuar para brincarmos o cliente Prisma!

## Brincando com o cliente de banco de dados Prisma {#playing-with-the-prisma-database-client}

Agora, vamos para o shell interativo do Blitz e brincar com o cliente de
banco de dados Prisma que o Blitz oferece. Para iniciar o console Blitz,
use este comando:

```sh
blitz console
```

Quando estiver no console, explore o cliente de banco de dados:

```sh
# No questions are in the system yet.
⚡ > await db.question.findMany()
[]

# Create a new Question:
⚡ > let q = await db.question.create({data: {text: "What's new?"}})
undefined

# See the entire object:
⚡ > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "What's new?"
}

# Or, access individual values on the object:
⚡ > q.text
"What's new?"

# Change values by using the update function:
⚡ > q = await db.question.update({where: {id: 1}, data: {text: "What's up?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "What's up?"
}

# db.question.findMany() now displays all the questions in the database:
⚡ > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "What's up?"
  }
]
```

## Update generated code for our model attributes {#update-generated-code-for-our-model-attributes}

<Card type="info">

Before running the app again, we need to customize some of the code that
has been generated. Ultimately, these fixes will not be needed - but for
now, we need to work around a couple outstanding issues.

</Card>

The generated page content does not currently use the actual model
attributes you defined during generation. It will soon, but in the
meantime, let's fix the generated pages.

### Question pages {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

Jump over to `app/pages/questions/index.tsx`. Notice that a
`QuestionsList` component has been generated for you:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{ questions, hasMore }, { isPreviousData }] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: { id: "asc" },
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    }
  )

  const goToPreviousPage = () =>
    router.push({ query: { page: page - 1 } })

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({ query: { page: page + 1 } })
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Next
      </button>
    </div>
  )
}
```

This won’t work though! Remember that the `Question` model we created
above doesn’t have any `name` field. To fix this, replace `question.name`
with `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

Next, let’s apply a similar fix to
`app/questions/components/QuestionForm.tsx`. In the form submission,
replace the `LabeledTextField` `name` to be `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Text" placeholder="Text" />
    </Form>
  )
}
```

### `createQuestion` mutation {#create-question-mutation}

In `app/questions/mutations/createQuestion.ts`, we need to update the
`CreateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `updateQuestion` mutation {#update-question-mutation}

In `app/questions/mutations/updateQuestion.ts`, we need to update the
`UpdateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:

```ts
await db.choice.deleteMany({ where: { questionId: id } })
```

The end result should be as such:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

This mutation will now delete the choices associated with the question
prior to deleting the question itself.

#### Now try creating, updating, and deleting questions

Great! Now make sure your app is running. If it isn’t, run `blitz dev` in
your terminal, and visit `localhost:3000/questions`. Try creating
questions, editing, and deleting them.

## Adding choices to the question form {#adding-choices-to-the-question-form}

You’re doing great so far! The next thing we’ll do is add choices to our
question form. Open `app/questions/components/QuestionForm.tsx` in your
editor.

Add three more `<LabeledTextField>` components as choices.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Text" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Choice 1" />
+     <LabeledTextField name="choices.1.text" label="Choice 2" />
+     <LabeledTextField name="choices.2.text" label="Choice 3" />
    </Form>
  )
}
```

Next open `app/pages/questions/new.tsx` and set `initialValues` to be as
follows:

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

Then open `app/questions/mutations/createQuestion.ts` and update the zod
schema so that the choice data is accepted in the mutation. And we also
need to update the `db.question.create` call so that the choices will also
be created.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### Try it out

Now you can go to `localhost:3000/questions/new` and create a new question
with choices!

## Listing choices {#listing-choices}

Time for a breather. Go back to `localhost:3000/questions` in your browser
and look at all the questions you‘ve created. How about we list these
questions’ choices here too? First, we need to customize the question
queries. In Prisma, you need to manually let the client know that you want
to query for nested relations. Change your `getQuestion.ts` and
`getQuestions.ts` files to look like this:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Now check `/questions` in the browser. **Magic!**

## Let’s let people vote on these questions! {#let-people-vote-on-questions}

Open `app/pages/questions/[questionId].tsx` in your editor. First, we’re
going to improve this page somewhat.

1. Replace `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Delete the `pre` element, and copy in our choices list which we wrote
   before:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

If you go back to your browser, your page should now look something like
this!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Now it’s time to add voting!

First we need to open `app/choices/mutations/updateChoice.ts`, update the
zod schema, and add a vote increment.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Now go back to `app/pages/questions/[questionId].tsx` and make the
following changes:

In our `li`, add a `button` like so:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

Then, import the `updateChoice` mutation we updated and create a
`handleVote` function in our page:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finally, we’ll tell our new `button` to call that function!

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

The final `Question` component should now look like this:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, { refetch }] = useQuery(getQuestion, {
    id: questionId,
  })
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({ id })
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({ id: question.id })
              router.push("/questions")
            }
          }}
          style={{ marginLeft: "0.5rem" }}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Lastly, let's allow editing choices for an existing question {#edit-choices-for-question}

If you click the **Edit** button on one of your existing questions, you'll
see it uses the same form as creating questions. So that part is already
done! We only need to update our mutation.

Open `app/questions/mutations/updateQuestion.ts` and make the following
changes:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+     include: {
+       choices: true,
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
is a special operation that means, "If this item exists, update it. Else
create it". This is perfect for this case because we didn't require the
user to add three choices when creating the question. So if later the user
adds another choice by editing the question, then it'll be created here.

## Cleanup {#cleanup}

In order for `yarn tsc` or `git push` to succeed, you'll need to delete
`app/choices/mutations/createChoice.ts` (unused) or update the
CreateChoice zod schema to include the required fields.

## Conclusion {#conclusion}

🥳 Congrats! You created your very own Blitz app! Have fun playing around
with it, or sharing it with your friends. Now that you’ve finished this
tutorial, why not try making your voting app even better? You could try:

- Adding styling (Hint, try `blitz install tailwind` or
  `blitz install chakra-ui`)
- Showing some more statistics about votes
- Deploying live on [Render](./deploy-render) or [Vercel](./deploy-vercel)

If you want to share your project with the world wide Blitz community
there is no better place to do that than on Discord.

Visit [discord.blitzjs.com](https://discord.blitzjs.com). Then, post the
link to the **#built-with-blitz** channel to share it with everyone!
