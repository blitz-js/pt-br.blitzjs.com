---
title: Tutorial
sidebar_label: Tutorial
---

Neste tutorial, vamos orient√°-lo na cria√ß√£o de um aplicativo b√°sico de
vota√ß√£o.

Vamos assumir que voc√™ j√° tenha o [Blitz instalado](./get-started). Voc√™
pode saber se o Blitz est√° instalado e qual vers√£o voc√™ possui executando
o seguinte comando em seu terminal:

```sh
blitz -v
```

Se o Blitz estiver instalado, voc√™ dever√° ver a vers√£o de sua instala√ß√£o.
Se n√£o estiver, voc√™ receber√° um erro dizendo algo como ‚Äúcommand not
found: blitz‚Äù.

## Criando um novo app {#creating-a-new-app}

Na linha de comando, v√° para a pasta onde deseja criar seu aplicativo e
execute o seguinte comando:

```sh
blitz new meu-app-blitz
```

Blitz criar√° uma pasta `meu-app-blitz` em sua pasta atual. Voc√™ ser√°
solicitado a escolher uma biblioteca de formul√°rios. Para este tutorial,
selecione a biblioteca recomendada `React Final Form`.

Vejamos o que `blitz new` criou:

```
meu-app-blitz
‚îú‚îÄ‚îÄ app/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mutations/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ changePassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logout.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgot-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validations.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Form.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ LabeledTextField.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ layouts/
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ Layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 404.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _app.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _document.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.test.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ users/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ queries/
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ getCurrentUser.ts
‚îú‚îÄ‚îÄ db/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ seeds.ts
‚îú‚îÄ‚îÄ integrations/
‚îú‚îÄ‚îÄ mailers/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ forgotPasswordMailer.ts
‚îú‚îÄ‚îÄ public/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico*
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ test/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.tsx
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ blitz.config.js
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ types.d.ts
‚îú‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ yarn.lock
```

Esses arquivos s√£o:

- A pasta `app/` √© um cont√™iner para a maior parte do seu projeto. √â aqui
  que voc√™ colocar√° todas as p√°ginas ou rotas de API.

- A pasta `app/pages/` √© a principal pasta das p√°ginas. Se voc√™ j√° usou
  Next.js, notar√° essa diferen√ßa imediatamente. No Blitz, voc√™ pode ter
  muitas pastas `pages` e elas ser√£o mescladas no momento da constru√ß√£o
  (build time).

- A pasta `app/core/` √© o principal local para colocar componentes, hooks,
  etc, que s√£o usados em todo o seu app.

- `db/` √© onde vai a configura√ß√£o do seu banco de dados. Se voc√™ estiver
  escrevendo modelos ou verificando migra√ß√µes (migrations), √© aqui que
  voc√™ deve verificar.

- `public/` √© a pasta onde voc√™ colocar√° quaisquer ativos est√°ticos. Se
  voc√™ tiver imagens, arquivos ou v√≠deos que deseja usar em seu app, aqui
  √© onde voc√™ deve coloc√°-los.

- `.babelrc.js`, `.env`, etc. ("dotfiles") s√£o arquivos de configura√ß√£o
  para v√°rias ferramentas JavaScript.

- `blitz.config.js` √© para configura√ß√£o personalizada avan√ßada do Blitz.
  Utiliza o mesmo formato que o `next.config.js`.

- `tsconfig.json` √© nossa configura√ß√£o recomendada para TypeScript.

## O servidor de desenvolvimento {#the-development-server}

Agora certifique-se de que est√° na pasta `meu-app-blitz` e execute o
seguinte comando:

```sh
blitz dev
```

Voc√™ ver√° a seguinte sa√≠da na linha de comando:

```sh
‚úî Compiled
Loaded env from /private/tmp/meu-app-blitz/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /meu-app-blitz/babel.config.js
event - compiled successfully
```

Agora que o servidor est√° em execu√ß√£o, visite
[localhost:3000](http://localhost:3000) com seu navegador. Voc√™ ver√° uma
p√°gina de boas-vindas, com o logotipo do Blitz. It worked!

## Cadastre-se como um usu√°rio {#sign-up-as-a-user}

Os apps Blitz s√£o criados com o cadastro e login de usu√°rio j√°
configurados! Ent√£o, vamos testar. Clique no bot√£o **Sign Up**
(Cadastrar-se). Digite qualquer e-mail e senha e clique em **Create
Account** (Criar Conta). Em seguida, voc√™ ser√° redirecionado de volta para
a p√°gina inicial, onde pode ver seu usu√°rio `id` e `role`.

Se quiser, voc√™ tamb√©m pode tentar sair e fazer login novamente. Ou clique
em **Forgot your password?** (Esqueceu sua senha?) na p√°gina de login para
testar esse fluxo.

## Escreva sua primeira p√°gina {#write-your-first-page}

Em seguida, vamos criar sua primeira p√°gina.

Abra o arquivo `app/pages/index.tsx` e substitua o conte√∫do do componente
`Home` por:

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Hello, world!</h1>

      <Suspense fallback="Carregando...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Salve o arquivo e voc√™ ver√° a atualiza√ß√£o da p√°gina em seu navegador. Voc√™
pode personalizar isso o quanto quiser. Quando estiver pronto, v√° para a
pr√≥xima se√ß√£o.

## Configura√ß√£o de banco de dados {#database-setup}

Boas not√≠cias, um banco de dados SQLite j√° foi configurado para voc√™! Voc√™
pode executar o `blitz prisma studio` no terminal para abrir uma interface
web onde voc√™ pode ver os dados de seu banco de dados.

Observe que ao iniciar seu primeiro projeto real, voc√™ pode querer usar um
banco de dados mais escal√°vel como o PostgreSQL, para evitar o inc√¥modo de
alterar seu banco de dados ao longo do caminho. Para obter mais
informa√ß√µes, consulte [Vis√£o geral do banco de dados](database-overview).
Por enquanto, continuaremos com o banco de dados padr√£o SQLite.

## Gerando a estrutura dos nossos modelos {#scaffolding-code-for-our-models}

O Blitz fornece um comando pr√°tico de CLI chamado
[`generate`](./cli-generate) para gerar a estrutura inicial do nosso
c√≥digo. Usaremos `generate` para criar dois modelos: `Question` (Quest√£o)
e `Choice` (Op√ß√£o). Uma `Question` cont√©m o texto da pergunta e uma lista
de op√ß√µes. Uma `Choice` tem o texto da op√ß√£o, uma contagem de votos e uma
quest√£o associada. O Blitz ir√° gerar automaticamente um id, um timestamp
(data e hora) de cria√ß√£o e um timestamp da √∫ltima atualiza√ß√£o para ambos
os modelos.

#### Primeiro, vamos gerar tudo o que pertence ao modelo `Question`:

```sh
blitz generate all question text:string
```

E quando solicitado, pressione **Enter** para executar `prisma migrate`
que ir√° atualizar seu esquema de banco de dados com o novo modelo. Ele
pedir√° um nome, ent√£o digite algo como "add question" (adicionar
pergunta).

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
‚úî Compiled
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

‚úî Model 'Question' created in schema.prisma:

>
> model Question {
>   id        Int      @id @default(autoincrement())
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }
>

‚úî Run 'prisma migrate dev' to update your database? (Y/n) ¬∑ true
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Enter a name for the new migration: ‚Ä¶ add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210722070215_add_question/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.

‚úî Generated Prisma Client (2.27.0) to ./node_modules/@prisma/client in 187ms
```

O comando `generate` do tipo `all` gera um model (modelo), queries,
mutations e arquivos de p√°gina. Veja a p√°gina
[Blitz generate](./cli-generate) para ver a lista de op√ß√µes dispon√≠veis.

#### A seguir, geraremos o modelo `Choice` com suas queries e mutations correspondentes.

Vamos passar o tipo `resource` (recurso) desta vez, pois n√£o precisamos
gerar p√°ginas para o modelo `Choice`:

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

Se voc√™ receber um erro, execute `blitz prisma format`.

Note que isso n√£o requer uma migra√ß√£o de banco de dados porque ainda n√£o
adicionamos o campo `Choice` ao modelo `Question`. Portanto, estamos
escolhendo `false` quando solicitado para executar a migra√ß√£o:

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

‚úî Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) ‚Ä∫ false
```

#### Por √∫ltimo, vamos atualizar o modelo `Question` para ter um relacionamento de volta com `Choice`.

Abra o `db/schema.prisma` e adicione `choices Choice[]` ao modelo
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

Agora podemos executar a migra√ß√£o para atualizar nosso banco de dados:

```sh
blitz prisma migrate dev
```

E novamente, insira um nome para a migra√ß√£o, como "add choice" (adicionar
op√ß√£o):

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Name of migration ‚Ä¶ add choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210412175528_add_choice/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.
```

Agora nosso banco de dados est√° pronto e um cliente Prisma tamb√©m foi
gerado. Vamos continuar para testarmos o cliente Prisma!

## Testando o cliente de banco de dados Prisma {#playing-with-the-prisma-database-client}

Agora, vamos para o shell interativo do Blitz e testar o cliente de banco
de dados Prisma que o Blitz oferece. Para iniciar o console Blitz, use
este comando:

```sh
blitz console
```

Quando estiver no console, explore o cliente de banco de dados:

```sh
# Ainda n√£o h√° perguntas no sistema.
‚ö° > await db.question.findMany()
[]

# Crie uma nova Pergunta:
‚ö° > let q = await db.question.create({data: {text: "Quais as novidades?"}})
undefined

# Veja o objeto inteiro:
‚ö° > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "Quais as novidades?"
}

# Ou acesse valores individuais no objeto:
‚ö° > q.text
"Quais as novidades?"

# Altere os valores usando a fun√ß√£o de update:
‚ö° > q = await db.question.update({where: {id: 1}, data: {text: "E a√≠?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "E a√≠?"
}

# db.question.findMany() agora exibe todas as perguntas do banco de dados:
‚ö° > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "E a√≠?"
  }
]
```

## Atualize o c√≥digo gerado para os atributos do nosso modelo {#update-generated-code-for-our-model-attributes}

<Card type="info">

Antes de executar o app novamente, precisamos personalizar parte do c√≥digo
que foi gerado. No final das contas, essas corre√ß√µes n√£o ser√£o
necess√°rias - mas, por enquanto, precisamos solucionar alguns problemas
pendentes.

</Card>

No momento, o conte√∫do gerado da p√°gina n√£o usa os atributos do modelo
real que voc√™ definiu durante a gera√ß√£o. Ir√° usar em breve, mas enquanto
isso, vamos corrigir as p√°ginas geradas.

### P√°ginas das Perguntas {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

V√° para `app/pages/questions/index.tsx`. Observe que um componente
`QuestionsList` foi gerado para voc√™:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{ questions, hasMore }, { isPreviousData }] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: { id: "asc" },
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    }
  )

  const goToPreviousPage = () =>
    router.push({ query: { page: page - 1 } })

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({ query: { page: page + 1 } })
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Anterior
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Pr√≥ximo
      </button>
    </div>
  )
}
```

Mas isso n√£o vai funcionar! Lembre-se de que o modelo `Question` que
criamos acima n√£o possui nenhum campo `name`. Para corrigir isso,
substitua `question.name` por `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Anterior
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Pr√≥ximo
      </button>
    </div>
  )
}
```

A seguir, vamos aplicar uma corre√ß√£o semelhante a
`app/questions/components/QuestionForm.tsx`. No envio do formul√°rio,
substitua o `LabeledTextField` `name` por `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Texto" placeholder="Texto" />
    </Form>
  )
}
```

### `createQuestion` mutation {#create-question-mutation}

Em `app/questions/mutations/createQuestion.ts`, precisamos atualizar o
esquema de valida√ß√£o do zod `CreateQuestion` para usar `text` em vez de
`name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `updateQuestion` mutation {#update-question-mutation}

Em `app/questions/mutations/updateQuestion.ts`, precisamos atualizar o
esquema de valida√ß√£o do zod `UpdateQuestion` para usar `text` em vez de
`name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:

O Prisma ainda n√£o suporta "cascading deletes". No contexto deste
tutorial, isso significa que atualmente ele n√£o exclui os dados de
`Choice` ao excluir uma `Question`. Precisamos alterar temporariamente a
mutation `deleteQuestion` gerada para fazer isso manualmente. Abra
`app/questions/mutations/deleteQuestion.ts` em seu editor de texto e
adicione o seguinte ao topo do corpo da fun√ß√£o:

```ts
await db.choice.deleteMany({ where: { questionId: id } })
```

O resultado final deve ser o seguinte:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

Esta mutation agora excluir√° as op√ß√µes associadas √† pergunta antes de
excluir a pr√≥pria pergunta.

#### Agora tente criar, atualizar e excluir perguntas

Excelente! Agora certifique-se de que seu app esteja em execu√ß√£o. Se n√£o
estiver, execute `blitz dev` em seu terminal e visite
`localhost:3000/questions`. Tente criar perguntas, editar e exclu√≠-las.

## Adicionando op√ß√µes ao formul√°rio da pergunta {#adding-choices-to-the-question-form}

Voc√™ est√° indo muito bem at√© agora! A pr√≥xima coisa que faremos √©
adicionar op√ß√µes ao nosso formul√°rio de perguntas. Abra
`app/questions/components/QuestionForm.tsx` em seu editor.

Adicione mais tr√™s componentes `<LabeledTextField>` como op√ß√µes.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Texto" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Op√ß√£o 1" />
+     <LabeledTextField name="choices.1.text" label="Op√ß√£o 2" />
+     <LabeledTextField name="choices.2.text" label="Op√ß√£o 3" />
    </Form>
  )
}
```

Em seguida, abra `app/pages/questions/new.tsx` e defina o `initialValues`
como a seguir:

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

Em seguida, abra `app/questions/mutations/createQuestion.ts` e atualize o
esquema do zod para que os dados das op√ß√µes sejam aceitos na mutation. E
tamb√©m precisamos atualizar a chamada `db.question.create` para que as
op√ß√µes tamb√©m sejam criadas.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### Experimente

Agora voc√™ pode ir para `localhost:3000/questions/new` e criar uma nova
quest√£o com op√ß√µes!

## Listando as op√ß√µes {#listing-choices}

√â hora de respirar. Volte para `localhost:3000/questions` em seu navegador
e veja todas as perguntas que voc√™ criou. Que tal listarmos as op√ß√µes
dessas quest√µes aqui tamb√©m? Primeiro, precisamos personalizar as
consultas das perguntas. No Prisma, voc√™ precisa informar manualmente ao
cliente que deseja consultar as rela√ß√µes aninhadas. Altere seus arquivos
`getQuestion.ts` e `getQuestions.ts` para ficarem assim:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // O tipo undefined √© aceito aqui mas ele √© necess√°rio em tempo de execu√ß√£o
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:

Agora volte em seu editor para nossa p√°gina principal de perguntas
(`app/pages/questions/index.tsx`), e poderemos listar as op√ß√µes de cada
pergunta. Adicione este c√≥digo abaixo do `Link` em nossa `QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votos
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Agora verifique `/questions` em seu navegador. **M√°gica!**

## Vamos deixar as pessoas votarem nessas quest√µes! {#let-people-vote-on-questions}

Abra `app/pages/questions/[questionId].tsx` em seu editor. Primeiro, vamos
melhorar um pouco esta p√°gina.

1. Substitua `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Exclua o elemento `pre` e copie nossa lista de op√ß√µes que escrevemos
   antes:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votos
    </li>
  ))}
</ul>
```

Se voc√™ voltar para o seu navegador, sua p√°gina deve ter uma apar√™ncia
semelhante a esta!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Agora √© hora de adicionar a vota√ß√£o!

Primeiro, precisamos abrir `app/choices/mutations/updateChoice.ts`,
atualizar o esquema do zod e adicionar um incremento de voto.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Agora volte para `app/pages/questions/[questionId].tsx` e fa√ßa as
seguintes altera√ß√µes:

Em nosso `li`, adicione um `button` como este:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votos
  <button>Votar</button>
</li>
```

Em seguida, importe a mutation `updateChoice` que atualizamos e crie uma
fun√ß√£o `handleVote` em nossa p√°gina:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Erro ao atualizar a op√ß√£o " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:

E ent√£o precisamos atualizar a chamada da question `useQuery` para
retornar a fun√ß√£o `refetch` que usamos dentro de `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finalmente, diremos ao nosso novo `button` para chamar essa fun√ß√£o!

```tsx
<button onClick={() => handleVote(choice.id)}>Votar</button>
```

O componente final `Question` agora deve ter a seguinte apar√™ncia:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, { refetch }] = useQuery(getQuestion, {
    id: questionId,
  })
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({ id })
      refetch()
    } catch (error) {
      alert("Erro ao atualizar a op√ß√£o " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Quest√£o {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votos
              <button onClick={() => handleVote(choice.id)}>Votar</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Editar</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("Isso ser√° exclu√≠do")) {
              await deleteQuestionMutation({ id: question.id })
              router.push("/questions")
            }
          }}
          style={{ marginLeft: "0.5rem" }}
        >
          Excluir
        </button>
      </div>
    </>
  )
}
```

## Por √∫ltimo, vamos permitir a edi√ß√£o de op√ß√µes para uma quest√£o existente {#edit-choices-for-question}

Se voc√™ clicar no bot√£o **Editar** em uma de suas perguntas existentes,
ver√° que ele usa o mesmo formul√°rio para criar perguntas. Ent√£o essa parte
j√° est√° feita! Precisamos apenas atualizar nossa mutation.

Abra `app/questions/mutations/updateQuestion.ts` e fa√ßa as seguintes
altera√ß√µes:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Parece ser um bug do prisma,
+           // porque `|| 0` n√£o deveria ser necess√°rio
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+     include: {
+       choices: true,
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
√© uma opera√ß√£o especial que significa: "Se este item existir, atualize-o.
Caso contr√°rio, crie-o". Isso √© perfeito para este caso porque n√£o
exigimos que o usu√°rio adicionasse tr√™s op√ß√µes ao criar a pergunta.
Portanto, se posteriormente o usu√°rio adicionar outra escolha editando a
quest√£o, ela ser√° criada aqui.

## Limpeza {#cleanup}

Para que `yarn tsc` ou `git push` tenham sucesso, voc√™ precisar√° excluir
`app/choices/mutations/createChoice.ts` (n√£o utilzado) ou atualizar o
esquema do zod `CreateChoice` para incluir os campos obrigat√≥rios.

## Conclus√£o {#conclusion}

ü•≥ Parab√©ns! Voc√™ criou seu pr√≥prio app Blitz! Divirta-se brincando com
ele ou compartilhando com seus amigos. Agora que voc√™ concluiu este
tutorial, por que n√£o tentar tornar seu app de vota√ß√£o ainda melhor? Voc√™
poderia tentar:

- Adicionar estilos (Dica, tente `blitz install tailwind` ou
  `blitz install chakra-ui`)
- Mostrar mais algumas estat√≠sticas sobre os votos
- Realizar o deploy em [Render](./deploy-render) ou
  [Vercel](./deploy-vercel)

Se voc√™ deseja compartilhar seu projeto com a comunidade Blitz mundial,
n√£o h√° lugar melhor para fazer isso do que no Discord.

Visite [discord.blitzjs.com](https://discord.blitzjs.com). Em seguida,
poste o link para o canal **#built-with-blitz** para compartilh√°-lo com
todos!
